<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ladders</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            background: rgba(20, 20, 35, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(100, 100, 150, 0.3);
        }

        h1 {
            text-align: center;
            font-size: 3em;
            margin-bottom: 10px;
            letter-spacing: 8px;
            color: #88ccff;
            text-shadow: 0 0 20px rgba(136, 204, 255, 0.5);
        }

        .subtitle {
            text-align: center;
            font-size: 0.9em;
            color: #999;
            margin-bottom: 40px;
            letter-spacing: 3px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        .control-section {
            background: rgba(30, 30, 50, 0.6);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(100, 100, 150, 0.2);
        }

        .section-title {
            font-size: 1.2em;
            margin-bottom: 20px;
            color: #88ccff;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid rgba(136, 204, 255, 0.3);
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider-control {
            margin-bottom: 20px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #bbb;
        }

        .slider-value {
            color: #88ccff;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, rgba(136, 204, 255, 0.2) 0%, rgba(136, 204, 255, 0.5) 100%);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #88ccff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(136, 204, 255, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #88ccff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(136, 204, 255, 0.8);
            border: none;
        }

        .voice-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 40px;
        }

        .voice-indicator {
            background: rgba(40, 40, 60, 0.6);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid rgba(100, 100, 150, 0.3);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .voice-indicator.active {
            border-color: #88ccff;
            box-shadow: 0 0 20px rgba(136, 204, 255, 0.5);
        }

        .voice-indicator.muted {
            opacity: 0.4;
            background: rgba(40, 40, 60, 0.3);
        }

        .voice-mute-btn {
            padding: 6px 12px;
            font-size: 0.75em;
            background: rgba(136, 204, 255, 0.15);
            color: #88ccff;
            border: 1px solid #88ccff;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .voice-mute-btn:hover {
            background: rgba(136, 204, 255, 0.3);
        }

        .voice-mute-btn.muted {
            background: rgba(255, 100, 100, 0.3);
            color: #ff6464;
            border-color: #ff6464;
        }

        .voice-number {
            font-size: 2em;
            color: #88ccff;
            margin-bottom: 10px;
        }

        .voice-note {
            font-size: 0.9em;
            color: #999;
        }

        .sequencer-viz {
            background: rgba(30, 30, 50, 0.6);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 40px;
            border: 1px solid rgba(100, 100, 150, 0.2);
            min-height: 200px;
        }

        .sequencer-row {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            align-items: center;
        }

        .seq-voice-label {
            width: 80px;
            font-size: 0.7em;
            color: #88ccff;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .seq-reseed-btn {
            padding: 3px 8px;
            font-size: 0.9em;
            background: rgba(136, 204, 255, 0.2);
            color: #88ccff;
            border: 1px solid #88ccff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .seq-reseed-btn:hover {
            background: rgba(136, 204, 255, 0.4);
        }

        .seq-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 80px;
        }

        .seq-controls select {
            padding: 4px;
            font-size: 0.75em;
            background: rgba(40, 40, 60, 0.8);
            color: #e0e0e0;
            border: 1px solid rgba(136, 204, 255, 0.3);
            border-radius: 4px;
        }

        .seq-length-input {
            padding: 4px;
            font-size: 0.75em;
            background: rgba(40, 40, 60, 0.8);
            color: #e0e0e0;
            border: 1px solid rgba(136, 204, 255, 0.3);
            border-radius: 4px;
            width: 100%;
            font-family: 'Courier New', monospace;
        }

        .seq-length-input:focus {
            outline: none;
            border-color: #88ccff;
        }

        .seq-steps {
            display: flex;
            gap: 4px;
            flex: 1;
        }

        .seq-step {
            flex: 1;
            height: 30px;
            background: rgba(136, 204, 255, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(136, 204, 255, 0.3);
            transition: all 0.1s ease;
            cursor: pointer;
            position: relative;
        }

        .seq-step:hover {
            background: rgba(136, 204, 255, 0.2);
            border-color: rgba(136, 204, 255, 0.5);
        }

        .seq-step.active {
            background: rgba(136, 204, 255, 0.6);
            box-shadow: 0 0 10px rgba(136, 204, 255, 0.8);
        }

        .seq-step.inactive {
            background: rgba(60, 60, 80, 0.3);
            border-color: rgba(100, 100, 120, 0.2);
        }

        .seq-step.playing {
            background: #88ccff;
            transform: scale(1.1);
            z-index: 10;
        }

        .voice-editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .voice-editor-modal.active {
            display: flex;
        }

        .voice-editor-content {
            background: rgba(20, 20, 35, 0.98);
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #88ccff;
            box-shadow: 0 0 40px rgba(136, 204, 255, 0.6);
        }

        .voice-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .voice-editor-title {
            font-size: 1.5em;
            color: #88ccff;
            letter-spacing: 2px;
        }

        .close-btn {
            background: rgba(136, 204, 255, 0.2);
            color: #88ccff;
            border: 2px solid #88ccff;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .close-btn:hover {
            background: rgba(136, 204, 255, 0.4);
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }

        button {
            padding: 15px 30px;
            font-size: 1em;
            font-family: 'Courier New', monospace;
            background: rgba(136, 204, 255, 0.2);
            color: #88ccff;
            border: 2px solid #88ccff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 1px;
        }

        button:hover {
            background: rgba(136, 204, 255, 0.4);
            box-shadow: 0 0 20px rgba(136, 204, 255, 0.6);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: #88ccff;
            color: #0a0a0a;
        }

        .voice-edit-btn, .randomize-btn {
            width: 100%;
            margin-bottom: 10px;
            padding: 12px;
            background: rgba(136, 204, 255, 0.15);
            font-size: 0.9em;
        }

        .randomize-btn {
            padding: 6px 12px;
            font-size: 0.8em;
            width: auto;
        }

        .voice-edit-btn:hover, .randomize-btn:hover {
            background: rgba(136, 204, 255, 0.35);
        }

        select {
            width: 100%;
            padding: 10px;
            background: rgba(40, 40, 60, 0.8);
            color: #e0e0e0;
            border: 1px solid rgba(136, 204, 255, 0.3);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            cursor: pointer;
            margin-top: 5px;
        }

        select:focus {
            outline: none;
            border-color: #88ccff;
            box-shadow: 0 0 10px rgba(136, 204, 255, 0.4);
        }

        .status-bar {
            background: rgba(20, 20, 35, 0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 0.9em;
            color: #999;
            border: 1px solid rgba(100, 100, 150, 0.2);
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .voice-indicator.active .voice-number {
            animation: pulse 1s ease-in-out infinite;
        }

        .fx-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
        }

        .matrix-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .envelope-pool {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .envelope-card {
            background: rgba(18, 18, 36, 0.8);
            border: 1px solid rgba(136, 204, 255, 0.25);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .envelope-card header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #88ccff;
            font-size: 0.9em;
            letter-spacing: 1px;
        }

        .envelope-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 12px;
            font-size: 0.8em;
            color: #bbb;
        }

        .envelope-routing {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .envelope-routing select,
        .envelope-routing input[type="range"] {
            width: 100%;
        }

        .morph-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }

        .matrix-cell {
            background: rgba(30, 30, 50, 0.6);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(136, 204, 255, 0.2);
        }

        .pattern-bank {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 10px;
        }

        .pattern-btn {
            padding: 10px;
            font-size: 0.85em;
            background: rgba(136, 204, 255, 0.15);
            border: 1px solid rgba(136, 204, 255, 0.4);
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
        }

        .inline-btns {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .small-btn {
            padding: 6px 10px;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ladders</h1>
        <p class="subtitle">polytonal generative synthesizer</p>

        <div class="button-group">
            <button id="startBtn">START</button>
            <button id="stopBtn">STOP</button>
            <button id="globalReseedBtn">RESEED ALL</button>
            <button id="evolveBtn">EVOLVE: OFF</button>
        </div>

        <div class="voice-grid">
            <div class="voice-indicator" id="voice1">
                <div class="voice-number">1</div>
                <div class="voice-note">--</div>
                <button class="voice-mute-btn" data-voice="0">MUTE</button>
            </div>
            <div class="voice-indicator" id="voice2">
                <div class="voice-number">2</div>
                <div class="voice-note">--</div>
                <button class="voice-mute-btn" data-voice="1">MUTE</button>
            </div>
            <div class="voice-indicator" id="voice3">
                <div class="voice-number">3</div>
                <div class="voice-note">--</div>
                <button class="voice-mute-btn" data-voice="2">MUTE</button>
            </div>
            <div class="voice-indicator" id="voice4">
                <div class="voice-number">4</div>
                <div class="voice-note">--</div>
                <button class="voice-mute-btn" data-voice="3">MUTE</button>
            </div>
        </div>

        <div class="sequencer-viz">
            <div class="sequencer-row">
                <div class="seq-voice-label">
                    VOICE 1
                    <button class="seq-reseed-btn" data-voice="0">↻</button>
                </div>
                <div class="seq-controls">
                    <select class="seq-direction" data-voice="0">
                        <option value="forward">→</option>
                        <option value="backward">←</option>
                        <option value="pendulum">↔</option>
                        <option value="random">⚡</option>
                    </select>
                    <select class="seq-division" data-voice="0">
                        <option value="1">1/16</option>
                        <option value="2" selected>1/8</option>
                        <option value="4">1/4</option>
                        <option value="8">1/2</option>
                        <option value="16">1/1</option>
                    </select>
                    <input type="number" class="seq-length-input" data-voice="0" min="1" max="32" value="8" title="Sequence Length">
                </div>
                <div class="seq-steps" id="seq1"></div>
            </div>
            <div class="sequencer-row">
                <div class="seq-voice-label">
                    VOICE 2
                    <button class="seq-reseed-btn" data-voice="1">↻</button>
                </div>
                <div class="seq-controls">
                    <select class="seq-direction" data-voice="1">
                        <option value="forward">→</option>
                        <option value="backward">←</option>
                        <option value="pendulum">↔</option>
                        <option value="random">⚡</option>
                    </select>
                    <select class="seq-division" data-voice="1">
                        <option value="1">1/16</option>
                        <option value="2">1/8</option>
                        <option value="4" selected>1/4</option>
                        <option value="8">1/2</option>
                        <option value="16">1/1</option>
                    </select>
                    <input type="number" class="seq-length-input" data-voice="1" min="1" max="32" value="12" title="Sequence Length">
                </div>
                <div class="seq-steps" id="seq2"></div>
            </div>
            <div class="sequencer-row">
                <div class="seq-voice-label">
                    VOICE 3
                    <button class="seq-reseed-btn" data-voice="2">↻</button>
                </div>
                <div class="seq-controls">
                    <select class="seq-direction" data-voice="2">
                        <option value="forward">→</option>
                        <option value="backward">←</option>
                        <option value="pendulum" selected>↔</option>
                        <option value="random">⚡</option>
                    </select>
                    <select class="seq-division" data-voice="2">
                        <option value="1">1/16</option>
                        <option value="2">1/8</option>
                        <option value="4">1/4</option>
                        <option value="8" selected>1/2</option>
                        <option value="16">1/1</option>
                    </select>
                    <input type="number" class="seq-length-input" data-voice="2" min="1" max="32" value="16" title="Sequence Length">
                </div>
                <div class="seq-steps" id="seq3"></div>
            </div>
            <div class="sequencer-row">
                <div class="seq-voice-label">
                    VOICE 4
                    <button class="seq-reseed-btn" data-voice="3">↻</button>
                </div>
                <div class="seq-controls">
                    <select class="seq-direction" data-voice="3">
                        <option value="forward">→</option>
                        <option value="backward">←</option>
                        <option value="pendulum">↔</option>
                        <option value="random" selected>⚡</option>
                    </select>
                    <select class="seq-division" data-voice="3">
                        <option value="1">1/16</option>
                        <option value="2">1/8</option>
                        <option value="4">1/4</option>
                        <option value="8">1/2</option>
                        <option value="16" selected>1/1</option>
                    </select>
                    <input type="number" class="seq-length-input" data-voice="3" min="1" max="32" value="6" title="Sequence Length">
                </div>
                <div class="seq-steps" id="seq4"></div>
            </div>
        </div>

        <div class="controls-grid">
            <div class="control-section">
                <div class="section-title">Global</div>
                
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Tempo</span>
                        <span class="slider-value" id="tempoVal">120</span>
                    </div>
                    <input type="range" id="tempo" min="40" max="240" value="120" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Master Volume</span>
                        <span class="slider-value" id="volumeVal">50</span>
                    </div>
                    <input type="range" id="volume" min="0" max="100" value="50" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Root Note</span>
                    </div>
                    <select id="rootNote">
                        <option value="0">C</option>
                        <option value="1">C#</option>
                        <option value="2">D</option>
                        <option value="3">D#</option>
                        <option value="4">E</option>
                        <option value="5">F</option>
                        <option value="6">F#</option>
                        <option value="7">G</option>
                        <option value="8">G#</option>
                        <option value="9">A</option>
                        <option value="10">A#</option>
                        <option value="11">B</option>
                    </select>
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Scale</span>
                    </div>
                    <select id="scale">
                        <option value="major">Major</option>
                        <option value="minor">Minor</option>
                        <option value="dorian">Dorian</option>
                        <option value="phrygian">Phrygian</option>
                        <option value="lydian">Lydian</option>
                        <option value="mixolydian">Mixolydian</option>
                        <option value="aeolian">Aeolian</option>
                        <option value="locrian">Locrian</option>
                        <option value="harmonic">Harmonic Minor</option>
                        <option value="melodic">Melodic Minor</option>
                        <option value="pentatonic">Pentatonic</option>
                        <option value="blues">Blues</option>
                        <option value="chromatic">Chromatic</option>
                    </select>
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Evolution Rate</span>
                        <span class="slider-value" id="evolveRateVal">0</span>
                    </div>
                    <input type="range" id="evolveRate" min="0" max="100" value="0" step="1">
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">
                    Esoteric Macros
                    <button class="randomize-btn" id="randomizeMacros">RANDOM</button>
                </div>
                
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Ξ Fractal Depth</span>
                        <span class="slider-value" id="macro1Val">20</span>
                    </div>
                    <input type="range" id="macro1" min="0" max="100" value="20" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Ψ Phase Coupling</span>
                        <span class="slider-value" id="macro2Val">15</span>
                    </div>
                    <input type="range" id="macro2" min="0" max="100" value="15" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Ω Spectral Flux</span>
                        <span class="slider-value" id="macro3Val">10</span>
                    </div>
                    <input type="range" id="macro3" min="0" max="100" value="10" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Δ Harmonic Drift</span>
                        <span class="slider-value" id="macro4Val">5</span>
                    </div>
                    <input type="range" id="macro4" min="0" max="100" value="5" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Φ Modulation Web</span>
                        <span class="slider-value" id="macro5Val">25</span>
                    </div>
                    <input type="range" id="macro5" min="0" max="100" value="25" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Λ Cross-Synthesis</span>
                        <span class="slider-value" id="macro6Val">30</span>
                    </div>
                    <input type="range" id="macro6" min="0" max="100" value="30" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Θ Temporal Distort</span>
                        <span class="slider-value" id="macro7Val">0</span>
                    </div>
                    <input type="range" id="macro7" min="0" max="100" value="0" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Σ Entropy Index</span>
                        <span class="slider-value" id="macro8Val">10</span>
                    </div>
                    <input type="range" id="macro8" min="0" max="100" value="10" step="1">
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Voice Editors</div>
                
                <button class="voice-edit-btn" data-voice="0">EDIT VOICE 1</button>
                <button class="voice-edit-btn" data-voice="1">EDIT VOICE 2</button>
                <button class="voice-edit-btn" data-voice="2">EDIT VOICE 3</button>
                <button class="voice-edit-btn" data-voice="3">EDIT VOICE 4</button>
            </div>

            <div class="control-section">
                <div class="section-title">Sequencer</div>
                
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Branch Complexity</span>
                        <span class="slider-value" id="branchVal">3</span>
                    </div>
                    <input type="range" id="branch" min="0" max="7" value="3" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Mutation Amount</span>
                        <span class="slider-value" id="mutationVal">30</span>
                    </div>
                    <input type="range" id="mutation" min="0" max="100" value="30" step="1">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Path Variation</span>
                        <span class="slider-value" id="pathVal">50</span>
                    </div>
                    <input type="range" id="path" min="0" max="100" value="50" step="1">
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">FX Buses</div>
                <div class="fx-grid">
                    <div>
                        <div class="slider-control">
                            <div class="slider-label">
                                <span>Phaser Rate</span>
                                <span class="slider-value" id="phaserRateVal">0.25</span>
                            </div>
                            <input type="range" id="phaserRate" min="0.05" max="4" value="0.25" step="0.05">
                        </div>
                        <div class="slider-control">
                            <div class="slider-label">
                                <span>Phaser Feedback</span>
                                <span class="slider-value" id="phaserFeedbackVal">0.35</span>
                            </div>
                            <input type="range" id="phaserFeedback" min="0" max="0.7" value="0.35" step="0.05">
                        </div>
                    </div>
                    <div>
                        <div class="slider-control">
                            <div class="slider-label">
                                <span>Flanger Depth</span>
                                <span class="slider-value" id="flangerDepthVal">0.003</span>
                            </div>
                            <input type="range" id="flangerDepth" min="0.0005" max="0.01" value="0.003" step="0.0005">
                        </div>
                        <div class="slider-control">
                            <div class="slider-label">
                                <span>Flanger Feedback</span>
                                <span class="slider-value" id="flangerFeedbackVal">0.45</span>
                            </div>
                            <input type="range" id="flangerFeedback" min="0" max="0.7" value="0.45" step="0.05">
                        </div>
                    </div>
                    <div>
                        <div class="slider-control">
                            <div class="slider-label">
                                <span>Time Cube Delay (s)</span>
                                <span class="slider-value" id="delayTimeVal">2.5</span>
                            </div>
                            <input type="range" id="delayTime" min="0.25" max="24" value="2.5" step="0.25">
                        </div>
                        <div class="slider-control">
                            <div class="slider-label">
                                <span>Delay Feedback</span>
                                <span class="slider-value" id="delayFeedbackVal">0.5</span>
                            </div>
                            <input type="range" id="delayFeedback" min="0" max="0.7" value="0.5" step="0.05">
                        </div>
                    </div>
                    <div>
                        <div class="slider-control">
                            <div class="slider-label">
                                <span>FDN Reverb Mix</span>
                                <span class="slider-value" id="reverbMixVal">0.3</span>
                            </div>
                            <input type="range" id="reverbMix" min="0" max="1" value="0.3" step="0.05">
                        </div>
                        <div class="slider-control">
                            <div class="slider-label">
                                <span>Reverb Size</span>
                                <span class="slider-value" id="reverbSizeVal">0.7</span>
                            </div>
                            <input type="range" id="reverbSize" min="0.1" max="0.95" value="0.7" step="0.05">
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Envelope Pool & Matrix</div>
                <p style="color:#bbb; margin-bottom:10px;">32-slot complex envelope pool with up to 41 breakpoints per slot. Each envelope can loop, one-shot, or self-cycle and can be routed to harmonic stretch/slope, combs, warp, panning, voice envelopes, spectral morph, and four global DSP controls.</p>
                <div class="morph-row">
                    <div class="slider-control" style="margin-bottom:0;">
                        <div class="slider-label">
                            <span>Spectral Morph</span>
                            <span class="slider-value" id="spectralMorphVal">0.00</span>
                        </div>
                        <input type="range" id="spectralMorph" min="0" max="1" value="0" step="0.01">
                    </div>
                    <div class="inline-btns" style="justify-content:flex-end;">
                        <button class="small-btn" id="captureSnapshotA">CAPTURE SNAPSHOT A</button>
                        <button class="small-btn" id="captureSnapshotB">CAPTURE SNAPSHOT B</button>
                        <button class="small-btn" id="resetMorph">RESET MORPH</button>
                    </div>
                </div>

                <div class="matrix-grid" style="margin-top:14px;">
                    <div class="matrix-cell">
                        <strong>Envelope Triggers</strong>
                        <p style="margin-top:8px; color:#bbb;">Envelopes listen to per-voice end-of-cycle, clock, or other envelopes. Loop A/B positions create LFO-like motion or one-shot articulation.</p>
                        <div class="inline-btns">
                            <button class="small-btn" id="randomizeOneEnv">RANDOM ENVELOPE</button>
                            <button class="small-btn" id="randomizeAllEnvs">RANDOM ALL</button>
                        </div>
                    </div>
                    <div class="matrix-cell">
                        <strong>Mod Routing</strong>
                        <p style="margin-top:8px; color:#bbb;">Assign envelopes to spectral stretch/slope, warp, comb filters, per-voice ADSR offsets, stereo pan, or global DSP.</p>
                        <div class="inline-btns">
                            <button class="small-btn" id="reseedMatrix">RESEED MATRIX</button>
                            <select id="modOutputMode">
                                <option value="shapes">Shapes</option>
                                <option value="velocity">Velocity</option>
                                <option value="smooth">Smooth</option>
                                <option value="envelope">Envelope</option>
                            </select>
                        </div>
                    </div>
                    <div class="matrix-cell">
                        <strong>Reseed Scope</strong>
                        <p style="margin-top:8px; color:#bbb;">Choose how evolution and reseed behaviors target trunks, branches, lattices, or envelopes.</p>
                        <div class="inline-btns">
                            <button class="small-btn" data-reseed="trunk">TRUNK</button>
                            <button class="small-btn" data-reseed="branches">BRANCH</button>
                            <button class="small-btn" data-reseed="lattice">LATTICE</button>
                            <button class="small-btn" data-reseed="envelopes">ENVELOPES</button>
                        </div>
                    </div>
                </div>

                <div class="envelope-pool" id="envelopePool"></div>
            </div>

            <div class="control-section">
                <div class="section-title">Patterns & Presets</div>
                <div class="pattern-bank" id="patternBank"></div>
                <div class="inline-btns">
                    <button class="small-btn" id="savePattern">SAVE SLOT</button>
                    <button class="small-btn" id="loadPattern">LOAD SLOT</button>
                    <button class="small-btn" id="reseedPattern">RESEED SLOT</button>
                    <button class="small-btn" id="downloadState">DOWNLOAD JSON</button>
                </div>
            </div>
        </div>

        <div class="voice-editor-modal" id="voiceEditorModal">
            <div class="voice-editor-content">
                <div class="voice-editor-header">
                    <div class="voice-editor-title" id="voiceEditorTitle">VOICE 1 EDITOR</div>
                    <button class="close-btn" id="closeVoiceEditor">CLOSE</button>
                </div>

                <button class="randomize-btn" id="randomizeVoice" style="width: 100%; margin-bottom: 20px;">RANDOMIZE VOICE</button>

                <div class="control-section" style="margin-bottom: 20px;">
                    <div class="section-title">Synthesis</div>
                    
                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Spectral Morph</span>
                            <span class="slider-value" id="v_spectralVal">30</span>
                        </div>
                        <input type="range" id="v_spectral" class="voice-param" data-param="spectral" min="0" max="100" value="30" step="1">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Harmonic Stretch</span>
                            <span class="slider-value" id="v_stretchVal">0</span>
                        </div>
                        <input type="range" id="v_stretch" class="voice-param" data-param="stretch" min="0" max="100" value="0" step="1">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Harmonic Warp</span>
                            <span class="slider-value" id="v_warpVal">20</span>
                        </div>
                        <input type="range" id="v_warp" class="voice-param" data-param="warp" min="0" max="100" value="20" step="1">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Phase Distortion</span>
                            <span class="slider-value" id="v_phaseVal">15</span>
                        </div>
                        <input type="range" id="v_phase" class="voice-param" data-param="phase" min="0" max="100" value="15" step="1">
                    </div>
                </div>

                <div class="control-section" style="margin-bottom: 20px;">
                    <div class="section-title">Envelope</div>
                    
                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Attack</span>
                            <span class="slider-value" id="v_attackVal">10</span>
                        </div>
                        <input type="range" id="v_attack" class="voice-param" data-param="attack" min="1" max="1000" value="10" step="1">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Decay</span>
                            <span class="slider-value" id="v_decayVal">200</span>
                        </div>
                        <input type="range" id="v_decay" class="voice-param" data-param="decay" min="10" max="2000" value="200" step="10">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Sustain</span>
                            <span class="slider-value" id="v_sustainVal">60</span>
                        </div>
                        <input type="range" id="v_sustain" class="voice-param" data-param="sustain" min="0" max="100" value="60" step="1">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Release</span>
                            <span class="slider-value" id="v_releaseVal">300</span>
                        </div>
                        <input type="range" id="v_release" class="voice-param" data-param="release" min="10" max="3000" value="300" step="10">
                    </div>
                </div>

                <div class="control-section">
                    <div class="section-title">Filter</div>
                    
                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Filter Cutoff</span>
                            <span class="slider-value" id="v_cutoffVal">5000</span>
                        </div>
                        <input type="range" id="v_cutoff" class="voice-param" data-param="cutoff" min="100" max="20000" value="5000" step="100">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Filter Resonance</span>
                            <span class="slider-value" id="v_resonanceVal">5</span>
                        </div>
                        <input type="range" id="v_resonance" class="voice-param" data-param="resonance" min="0" max="30" value="5" step="0.5">
                    </div>
                </div>
            </div>
        </div>

        <div class="status-bar" id="status">
            Audio Engine: Inactive | Click START to begin
        </div>
    </div>

    <script>
    /** Step data shape for trunk/branches */
    /** @typedef {{note:number, velocity:number, gate:number, active:boolean, ratchet:number, slew:number, modValue:number, altOffset:number, probability:number}} Step */
    /** @typedef {{transform:'reverse'|'inverse'|'transpose'|'mutate'|'random', transpose:number, enabled:boolean}} Branch */
    /** @typedef {{gate:number, ratExtra:number, probability:number, alt:number}} LatticeCell */

    const branchTransforms = ['reverse','inverse','transpose','mutate','random'];
    const macroModes = ['shapes','velocity','smooth','envelope'];

    function normalizeMacroMode(mode) {
        return macroModes.includes(mode) ? mode : macroModes[0];
    }

    let audioContext;
    let masterGain;
    let limiter;
    let scheduler;
    let baseStepDuration = 0.125; // seconds at 120 bpm, updated by tempo control

    const voiceStates = Array.from({ length: 4 }, (_, i) => createVoiceState(i));
    const voiceMuted = [false, false, false, false];

    const fxBuses = {
        phaser: null,
        flanger: null,
        delay: null,
        reverb: null
    };

    const scales = {
        major: [0, 2, 4, 5, 7, 9, 11],
        minor: [0, 2, 3, 5, 7, 8, 10],
        dorian: [0, 2, 3, 5, 7, 9, 10],
        phrygian: [0, 1, 3, 5, 7, 8, 10],
        lydian: [0, 2, 4, 6, 7, 9, 11],
        mixolydian: [0, 2, 4, 5, 7, 9, 10],
        aeolian: [0, 2, 3, 5, 7, 8, 10],
        locrian: [0, 1, 3, 5, 6, 8, 10],
        harmonic: [0, 2, 3, 5, 7, 8, 11],
        melodic: [0, 2, 3, 5, 7, 9, 11],
        pentatonic: [0, 2, 4, 7, 9],
        blues: [0, 3, 5, 6, 7, 10],
        chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    };

    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    const macros = {
        fractalDepth: 20,
        phaseCoupling: 15,
        spectralFlux: 10,
        harmonicDrift: 5,
        modulationWeb: 25,
        crossSynthesis: 30,
        temporalDistort: 0,
        entropyIndex: 10
    };

    const dspGlobals = {
        drive: 0.25,
        diffusion: 0.6,
        space: 0.5,
        feedback: 0.4
    };

    const spectralSnapshots = { A: null, B: null };
    let spectralMorphAmount = 0;

    const voiceParams = [
        { spectral: 30, stretch: 0, warp: 20, phase: 15, slope: 0.4, comb: 0.2, even: 0.5, pan: -0.25, attack: 10, decay: 200, sustain: 60, release: 300, cutoff: 5000, resonance: 5 },
        { spectral: 25, stretch: 10, warp: 15, phase: 25, slope: 0.6, comb: 0.3, even: 0.55, pan: -0.05, attack: 25, decay: 350, sustain: 50, release: 500, cutoff: 3500, resonance: 8 },
        { spectral: 35, stretch: 20, warp: 25, phase: 10, slope: 0.35, comb: 0.15, even: 0.6, pan: 0.1, attack: 5, decay: 150, sustain: 70, release: 200, cutoff: 7000, resonance: 3 },
        { spectral: 20, stretch: 5, warp: 30, phase: 30, slope: 0.8, comb: 0.4, even: 0.45, pan: 0.35, attack: 50, decay: 600, sustain: 40, release: 800, cutoff: 2000, resonance: 12 }
    ];

    const voiceBaseParams = voiceParams.map(v => ({ ...v }));

    const patternBank = Array.from({ length: 16 }, () => null);
    let selectedPattern = 0;

    /** Helper data container */
    function createVoiceState(idx) {
        return {
            index: idx,
            trunk: [],
            branches: createDefaultBranches(),
            lattice: createDefaultLattice(),
            pathMode: 'forward',
            macroMode: macroModes[0],
            nextEventTime: 0,
            stepIndex: 0,
            synth: null
        };
    }

    function createDefaultLattice() {
        const row = () => Array.from({ length: 8 }, () => ({ gate: 1, ratExtra: 0, probability: 0.9, alt: 0 }));
        return {
            position: { x: 0, y: 0, z: 0 },
            dir: 'forward',
            jitterPct: 0.05,
            swingPct: 0.1,
            ratDepth: 1,
            ratProb: 0.25,
            clock: 120,
            divSeq: [2],
            cells: Array.from({ length: 8 }, row)
        };
    }

    function createDefaultBranches() {
        return branchTransforms.slice(0, 4).map((transform, i) => ({
            transform,
            transpose: i - 1,
            enabled: i < 2
        }));
    }

    class EnvelopeGenerator {
        constructor(index) {
            this.index = index;
            this.rate = 0.9 + (index % 6) * 0.05;
            this.amplitude = 0.55;
            this.segmentCount = 8;
            this.loopEnabled = true;
            this.loopA = 1;
            this.loopB = 4;
            this.rateModSource = 'clock';
            this.cycleSource = 'clock';
            this.lastTriggerTime = 0;
            this.breakpoints = [];
            this.timeline = [];
            this.randomizeBreakpoints();
        }

        randomizeBreakpoints() {
            this.segmentCount = clamp(3 + Math.floor(Math.random() * 12), 3, 40);
            const pointCount = Math.min(41, this.segmentCount + 1);
            this.breakpoints = [];
            let cursor = 0;
            for (let i = 0; i < pointCount; i++) {
                const duration = i === 0 ? 0 : 0.03 + Math.random() * 0.25;
                cursor += duration;
                this.breakpoints.push({ time: cursor, value: Math.random() });
            }
            this.loopA = Math.min(this.loopA, pointCount - 2);
            this.loopB = clamp(this.loopA + 1 + Math.floor(Math.random() * (pointCount - this.loopA - 1)), this.loopA + 1, pointCount - 1);
            this.rebuildTimeline();
        }

        randomize() {
            this.rate = 0.15 + Math.random() * 1.85;
            this.amplitude = 0.25 + Math.random() * 0.75;
            this.loopEnabled = Math.random() > 0.25;
            this.rateModSource = ['clock', 'macro', 'eoc'][Math.floor(Math.random() * 3)];
            this.cycleSource = ['clock', 'voice', 'envelope'][Math.floor(Math.random() * 3)];
            this.loopA = Math.floor(Math.random() * Math.max(1, this.segmentCount - 2));
            this.randomizeBreakpoints();
        }

        rebuildTimeline() {
            this.timeline = this.breakpoints.map(bp => bp.time / this.rate);
        }

        trigger(time) {
            this.lastTriggerTime = time;
        }

        valueAt(time) {
            if (!this.lastTriggerTime) return 0;
            const elapsed = Math.max(0, time - this.lastTriggerTime);
            if (this.timeline.length < 2) return 0;
            let localTime = elapsed;

            const total = this.timeline[this.timeline.length - 1];
            const loopStart = this.timeline[this.loopA];
            const loopEnd = this.timeline[this.loopB];

            if (this.loopEnabled && localTime > loopStart && loopEnd > loopStart) {
                const loopDur = loopEnd - loopStart;
                localTime = loopStart + ((localTime - loopStart) % loopDur);
            } else if (!this.loopEnabled && localTime > total) {
                return 0;
            }

            for (let i = 0; i < this.timeline.length - 1; i++) {
                const t0 = this.timeline[i];
                const t1 = this.timeline[i + 1];
                if (localTime >= t0 && localTime <= t1) {
                    const p0 = this.breakpoints[i];
                    const p1 = this.breakpoints[i + 1];
                    const norm = (localTime - t0) / Math.max(0.0001, t1 - t0);
                    const eased = Math.pow(norm, 1 + (i % 3));
                    return (p0.value + (p1.value - p0.value) * eased) * this.amplitude;
                }
            }
            return 0;
        }
    }

    const envelopePool = Array.from({ length: 32 }, (_, i) => new EnvelopeGenerator(i));

    const envelopeTargets = [
        { key: 'harmonicStretch', label: 'Harmonic Stretch' },
        { key: 'harmonicSlope', label: 'Harmonic Slope' },
        { key: 'comb', label: 'Comb Density' },
        { key: 'warp', label: 'Warp' },
        { key: 'phase', label: 'Phase Distortion' },
        { key: 'pan', label: 'Stereo Pan' },
        { key: 'adsr', label: 'ADSR Offset' },
        { key: 'dspA', label: 'DSP A' },
        { key: 'dspB', label: 'DSP B' },
        { key: 'dspC', label: 'DSP C' },
        { key: 'dspD', label: 'DSP D' },
        { key: 'morph', label: 'Spectral Morph' }
    ];

    const envelopeAssignments = Array.from({ length: 32 }, (_, i) => ({
        target: envelopeTargets[i % envelopeTargets.length].key,
        depth: 0.35 + (i % 5) * 0.05
    }));

    class FXPhaser {
        constructor(context) {
            this.context = context;
            this.input = context.createGain();
            this.output = context.createGain();
            this.lfo = context.createOscillator();
            this.lfoGain = context.createGain();
            this.feedback = context.createGain();
            this.allpasses = Array.from({ length: 4 }, () => context.createBiquadFilter());
            this.allpasses.forEach((ap, i) => {
                ap.type = 'allpass';
                ap.frequency.value = 400 * (i + 1);
            });
            this.lfo.connect(this.lfoGain);
            this.lfoGain.connect(this.allpasses[0].frequency);
            this.input.connect(this.allpasses[0]);
            for (let i = 0; i < this.allpasses.length - 1; i++) {
                this.allpasses[i].connect(this.allpasses[i + 1]);
            }
            this.allpasses[this.allpasses.length - 1].connect(this.output);
            this.allpasses[this.allpasses.length - 1].connect(this.feedback);
            this.feedback.connect(this.allpasses[0]);
            this.lfo.start();
        }

        update({ rate, feedback }) {
            const now = this.context.currentTime;
            const safeRate = clamp(rate, 0.05, 2);
            const safeFeedback = clamp(feedback, 0, 0.5);
            this.lfo.frequency.setTargetAtTime(safeRate, now, 0.05);
            this.lfoGain.gain.setTargetAtTime(80, now, 0.05);
            this.feedback.gain.setTargetAtTime(safeFeedback, now, 0.05);
        }
    }

    class FXFlanger {
        constructor(context) {
            this.context = context;
            this.input = context.createGain();
            this.output = context.createGain();
            this.delay = context.createDelay(0.02);
            this.lfo = context.createOscillator();
            this.lfoGain = context.createGain();
            this.feedback = context.createGain();
            this.input.connect(this.delay);
            this.delay.connect(this.feedback);
            this.feedback.connect(this.delay);
            this.delay.connect(this.output);
            this.input.connect(this.output);
            this.lfo.connect(this.lfoGain);
            this.lfoGain.connect(this.delay.delayTime);
            this.lfo.start();
        }

        update({ depth, feedback }) {
            const now = this.context.currentTime;
            this.lfo.frequency.setTargetAtTime(0.15, now, 0.05);
            this.lfoGain.gain.setTargetAtTime(depth, now, 0.05);
            this.feedback.gain.setTargetAtTime(clamp(feedback, 0, 0.7), now, 0.05);
        }
    }

    class FXDelay {
        constructor(context) {
            this.context = context;
            this.input = context.createGain();
            this.output = context.createGain();
            this.delay = context.createDelay(32);
            this.feedback = context.createGain();
            this.input.connect(this.delay);
            this.delay.connect(this.feedback);
            this.feedback.connect(this.delay);
            this.delay.connect(this.output);
            this.input.connect(this.output);
        }

        update({ time, feedback }) {
            const now = this.context.currentTime;
            this.delay.delayTime.setTargetAtTime(time, now, 0.05);
            this.feedback.gain.setTargetAtTime(clamp(feedback, 0, 0.7), now, 0.05);
        }
    }

    class FXReverb {
        constructor(context) {
            this.context = context;
            this.input = context.createGain();
            this.output = context.createGain();
            this.combA = context.createDelay(1.5);
            this.combB = context.createDelay(1.3);
            this.combFeedback = context.createGain();
            this.diffuse = context.createBiquadFilter();
            this.diffuse.type = 'lowpass';
            this.diffuse.frequency.value = 8000;
            this.wetGain = context.createGain();
            this.wetGain.gain.value = 0.6;
            this.input.connect(this.diffuse);
            this.diffuse.connect(this.combA);
            this.diffuse.connect(this.combB);
            this.combA.connect(this.combFeedback);
            this.combB.connect(this.combFeedback);
            this.combFeedback.connect(this.diffuse);
            this.combA.connect(this.wetGain);
            this.combB.connect(this.wetGain);
            this.wetGain.connect(this.output);
        }

        update({ mix, size }) {
            const t = 0.05;
            const safeSize = clamp(size, 0.1, 0.95);
            const safeMix = clamp(mix, 0, 1);
            const feedbackAmt = clamp(0.22 + safeSize * 0.2, 0, 0.55);
            const dampFreq = clamp(5000 - safeSize * 2500, 1200, 6000);
            this.combA.delayTime.setTargetAtTime(0.03 + safeSize * 0.5, this.context.currentTime, t);
            this.combB.delayTime.setTargetAtTime(0.025 + safeSize * 0.45, this.context.currentTime, t);
            this.diffuse.frequency.setTargetAtTime(dampFreq, this.context.currentTime, t);
            this.combFeedback.gain.setTargetAtTime(feedbackAmt, this.context.currentTime, t);
            this.wetGain.gain.setTargetAtTime(0.6, this.context.currentTime, t);
            this.output.gain.setTargetAtTime(safeMix * 0.7, this.context.currentTime, t);
        }
    }

    class SynthVoice {
        constructor(context, index, fx) {
            this.context = context;
            this.index = index;
            this.fx = fx;
            this.baseFreq = 220;
            this.outputGain = context.createGain();
            this.envelopeGain = context.createGain();
            this.envelopeGain.gain.setValueAtTime(0.0001, context.currentTime);
            this.panner = context.createStereoPanner();
            this.filter = context.createBiquadFilter();
            this.filter.type = 'lowpass';
            this.waveshaper = context.createWaveShaper();
            this.oscillators = [];
            this.gains = [];
            this.oscCount = 6;
            for (let i = 0; i < this.oscCount; i++) {
                const osc = context.createOscillator();
                osc.type = i % 2 === 0 ? 'sawtooth' : 'triangle';
                const g = context.createGain();
                g.gain.value = 0.15;
                osc.connect(g);
                g.connect(this.filter);
                this.oscillators.push(osc);
                this.gains.push(g);
                osc.start();
            }
            this.filter.connect(this.waveshaper);
            this.waveshaper.connect(this.envelopeGain);
            this.envelopeGain.connect(this.panner);
            this.panner.connect(this.outputGain);
            this.outputGain.connect(masterGain);
            this.fxSends = Object.values(this.fx).map(bus => {
                const send = context.createGain();
                send.gain.value = 0.15;
                this.envelopeGain.connect(send);
                if (bus) send.connect(bus.input);
                return send;
            });
            this.updateWaveshaperCurve();
        }

        makeCurve(drive = 1) {
            const curve = new Float32Array(2048);
            for (let i = 0; i < curve.length; i++) {
                const x = (i / curve.length) * 2 - 1;
                curve[i] = Math.tanh(x * (1.5 + drive * 1.5)) * (1 + Math.sin(x * 6) * 0.25 * drive);
            }
            return curve;
        }

        updateWaveshaperCurve() {
            this.waveshaper.curve = this.makeCurve(clamp(dspGlobals.drive, 0.2, 2));
        }

        setFrequencies(freq, time) {
            if (!Number.isFinite(freq) || freq <= 0) return;
            this.baseFreq = freq;
            const params = applyMacros(this.index);
            const baseParams = voiceBaseParams[this.index] || {};
            const ensureFinite = (val, fallback) => Number.isFinite(val) ? val : fallback;
            const safeParams = {
                stretch: ensureFinite(params.stretch, baseParams.stretch || 0),
                warp: ensureFinite(params.warp, baseParams.warp || 0),
                comb: ensureFinite(params.comb, baseParams.comb || 0),
                slope: ensureFinite(params.slope, baseParams.slope || 0.5),
                even: ensureFinite(params.even, baseParams.even || 0.5),
                pan: ensureFinite(params.pan, baseParams.pan || 0),
                cutoff: ensureFinite(params.cutoff, baseParams.cutoff || 1000),
                resonance: ensureFinite(params.resonance, baseParams.resonance || 1),
                attack: ensureFinite(params.attack, baseParams.attack || 10),
                decay: ensureFinite(params.decay, baseParams.decay || 100),
                sustain: ensureFinite(params.sustain, baseParams.sustain || 60),
                release: ensureFinite(params.release, baseParams.release || 200)
            };
            const now = time || this.context.currentTime;
            this.oscillators.forEach((osc, i) => {
                const partial = i + 1;
                let ratio = partial * (1 + safeParams.stretch / 200) * Math.pow(1 + safeParams.warp / 300, partial * 0.4);
                ratio += Math.sin(partial * 0.7) * safeParams.comb * 0.05;
                const target = Math.min(18000, this.baseFreq * ratio);
                osc.frequency.cancelScheduledValues(now);
                osc.frequency.setValueAtTime(target, now);
                const entropy = Number.isFinite(macros.entropyIndex) ? macros.entropyIndex : 0;
                osc.detune.setValueAtTime((Math.random() - 0.5) * entropy, now);
                let gain = 0.12 / partial;
                gain *= Math.pow(1.1 - clamp(safeParams.slope, 0, 1.2), partial * 0.22);
                const evenBias = safeParams.even || 0.5;
                gain *= partial % 2 === 0 ? (0.5 + evenBias) : (1.5 - evenBias);
                this.gains[i].gain.setTargetAtTime(clamp(gain, 0.01, 0.25), now, 0.02);
            });
            this.filter.frequency.setTargetAtTime(Math.max(200, safeParams.cutoff), now, 0.05);
            this.filter.Q.setTargetAtTime(safeParams.resonance, now, 0.05);
            this.panner.pan.setTargetAtTime(safeParams.pan || 0, now, 0.02);
            this.updateWaveshaperCurve();
        }

        trigger(note, velocity, gate, time) {
            const freq = midiToFreq(note);
            const now = time || this.context.currentTime;
            this.setFrequencies(freq, now);
            const params = applyMacros(this.index);
            const peak = Math.max(0.001, velocity / 127);
            const attack = Math.max(0.001, params.attack / 1000);
            const decay = Math.max(0.001, params.decay / 1000);
            const sustain = Math.max(0.05, params.sustain / 100);
            const release = Math.max(0.01, params.release / 1000);

            this.envelopeGain.gain.cancelScheduledValues(now);
            this.envelopeGain.gain.setValueAtTime(0.0001, now);
            this.envelopeGain.gain.linearRampToValueAtTime(peak, now + attack);
            this.envelopeGain.gain.linearRampToValueAtTime(peak * sustain, now + attack + decay);
            const gateEnd = now + gate;
            this.envelopeGain.gain.setValueAtTime(peak * sustain, gateEnd);
            this.envelopeGain.gain.linearRampToValueAtTime(0.0001, gateEnd + release);
        }

        setSend(index, amount) {
            if (this.fxSends[index]) {
                this.fxSends[index].gain.setTargetAtTime(amount, this.context.currentTime, 0.1);
            }
        }
    }

    class WebAudioScheduler {
        constructor(context, scheduleFn) {
            this.context = context;
            this.scheduleFn = scheduleFn;
            this.lookAhead = 0.1;
            this.tickInterval = 0.02;
            this.running = false;
            this.timer = null;
        }

        start() {
            if (this.running) return;
            this.running = true;
            this.timer = setTimeout(() => this.tick(), this.tickInterval * 1000);
        }

        stop() {
            this.running = false;
            clearTimeout(this.timer);
        }

        tick() {
            if (!this.running) return;
            const now = this.context.currentTime;
            this.scheduleFn(now, this.lookAhead);
            this.timer = setTimeout(() => this.tick(), this.tickInterval * 1000);
        }
    }

    class PatternManager {
        constructor(bank) {
            this.bank = bank;
        }
        save(slot) {
            this.bank[slot] = JSON.stringify(voiceStates.map(v => ({
                trunk: v.trunk,
                branches: v.branches,
                lattice: v.lattice,
                macroMode: v.macroMode
            })));
            localStorage.setItem('ladders-bank-' + slot, this.bank[slot]);
        }
        load(slot) {
            const payload = this.bank[slot] || localStorage.getItem('ladders-bank-' + slot);
            if (!payload) return;
            const data = JSON.parse(payload);
            data.forEach((state, i) => {
                voiceStates[i].trunk = state.trunk;
                voiceStates[i].branches = state.branches;
                voiceStates[i].lattice = state.lattice;
                voiceStates[i].macroMode = state.macroMode;
                updateSequenceViz(i);
            });
        }
        reseed(slot) {
            generateAllSequences();
            this.save(slot);
        }
        export() {
            return JSON.stringify({ voices: voiceStates, macros, voiceParams, dspGlobals, envelopeAssignments }, null, 2);
        }
    }

    const patternManager = new PatternManager(patternBank);

    function midiToFreq(midi) {
        const note = Number(midi);
        if (!Number.isFinite(note)) return 0;
        return 440 * Math.pow(2, (note - 69) / 12);
    }

    function midiToNoteName(midi) {
        const octave = Math.floor(midi / 12) - 1;
        const note = noteNames[midi % 12];
        return `${note}${octave}`;
    }

    function quantizeToScale(midi) {
        const noteValue = Number.isFinite(midi) ? midi : 60;
        const rootInput = parseInt(document.getElementById('rootNote').value);
        const root = Number.isFinite(rootInput) ? rootInput : 60;
        const scaleName = document.getElementById('scale').value;
        const scaleIntervals = scales[scaleName] || scales.major;
        const noteRelative = noteValue - root;
        const octave = Math.floor(noteRelative / 12);
        const noteInOctave = ((noteRelative % 12) + 12) % 12;
        let closestInterval = scaleIntervals[0];
        let minDistance = Math.abs(noteInOctave - closestInterval);
        for (let interval of scaleIntervals) {
            const distance = Math.abs(noteInOctave - interval);
            if (distance < minDistance) {
                minDistance = distance;
                closestInterval = interval;
            }
        }
        return root + octave * 12 + closestInterval;
    }

    function generateWavetables() {
        const waveforms = [];
        const size = 2048;
        for (let i = 0; i < 8; i++) {
            const real = new Float32Array(size);
            const imag = new Float32Array(size);
            for (let j = 1; j < 32; j++) {
                real[j] = Math.sin(j * i) / j;
                imag[j] = Math.cos(j * i) / j;
            }
            waveforms.push(audioContext ? audioContext.createPeriodicWave(real, imag) : null);
        }
        return waveforms;
    }

    const wavetables = generateWavetables();

    function applyMacros(voiceIdx) {
        const v = voiceParams[voiceIdx];
        const m = macros;
        const fractalDepth = m.fractalDepth / 100;
        const harmonicMultiplier = 1 + fractalDepth * 2;
        const coupling = m.phaseCoupling / 100;
        const fluxAmount = Math.sin(performance.now() * 0.001 * (m.spectralFlux / 10)) * 15;
        const entropy = m.entropyIndex / 100;
        const morphPush = spectralMorphAmount * 0.5;
        const combInfluence = v.comb + spectralMorphAmount * 0.6;
        return {
            spectral: clamp(v.spectral + fluxAmount + spectralMorphAmount * 50, 0, 140),
            stretch: clamp(v.stretch * harmonicMultiplier + combInfluence * 20, 0, 140),
            warp: clamp(v.warp + coupling * 40 + morphPush * 60, 0, 140),
            phase: clamp(v.phase * (1 + coupling * 0.6), 0, 140),
            slope: clamp(v.slope + m.crossSynthesis / 300, 0, 2.5),
            comb: clamp(combInfluence, 0, 2.5),
            even: clamp(v.even + Math.sin(performance.now() * 0.0005) * 0.1, 0, 1),
            pan: clamp(v.pan + (m.temporalDistort / 100 - 0.5) * 0.35, -1, 1),
            attack: v.attack * (1 + entropy * 0.5),
            decay: v.decay * (1 + entropy * 0.4),
            sustain: v.sustain * (1 - entropy * 0.2),
            release: v.release * (1 + entropy * 0.6),
            cutoff: v.cutoff * (1 + m.modulationWeb / 400) * (1 + dspGlobals.diffusion * 0.1),
            resonance: v.resonance * (1 + coupling + dspGlobals.drive * 0.1),
        };
    }

    function captureSpectralSnapshot(slot) {
        spectralSnapshots[slot] = {
            voices: voiceBaseParams.map(v => ({ ...v })),
            macros: { ...macros },
            dsp: { ...dspGlobals }
        };
    }

    function applySpectralMorph() {
        document.getElementById('spectralMorphVal').textContent = spectralMorphAmount.toFixed(2);
        const morphSlider = document.getElementById('spectralMorph');
        if (morphSlider) morphSlider.value = spectralMorphAmount;
        const a = spectralSnapshots.A;
        const b = spectralSnapshots.B;
        if (!a || !b) return;
        const t = spectralMorphAmount;
        const lerp = (x, y) => x + (y - x) * t;
        for (let i = 0; i < voiceBaseParams.length; i++) {
            const keys = Object.keys(voiceBaseParams[i]);
            keys.forEach(key => {
                const av = a.voices[i][key];
                const bv = b.voices[i][key];
                if (typeof av === 'number' && typeof bv === 'number') {
                    voiceBaseParams[i][key] = lerp(av, bv);
                }
            });
            voiceParams[i] = { ...voiceBaseParams[i] };
        }
        Object.keys(macros).forEach(k => {
            if (typeof a.macros[k] === 'number' && typeof b.macros[k] === 'number') {
                macros[k] = lerp(a.macros[k], b.macros[k]);
            }
        });
        Object.keys(dspGlobals).forEach(k => {
            if (typeof a.dsp[k] === 'number' && typeof b.dsp[k] === 'number') {
                dspGlobals[k] = lerp(a.dsp[k], b.dsp[k]);
            }
        });
    }

    function resetMorph() {
        spectralMorphAmount = 0;
        applySpectralMorph();
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function randomStep(root) {
        const note = quantizeToScale(root + (Math.floor(Math.random() * 14) - 7));
        return {
            note,
            velocity: 90,
            gate: 0.6 + Math.random() * 0.3,
            active: Math.random() > 0.05,
            ratchet: [1, 1, 2, 3, 4][Math.floor(Math.random() * 5)],
            slew: Math.random() * 0.4,
            modValue: Math.random(),
            altOffset: 0,
            probability: 0.9
        };
    }

    function mutateStep(step, intensity) {
        const copy = { ...step };
        if (Math.random() < intensity) copy.note = quantizeToScale(copy.note + (Math.random() > 0.5 ? 2 : -2));
        if (Math.random() < intensity * 0.5) copy.gate = clamp(copy.gate + (Math.random() - 0.5) * 0.4, 0.1, 1.2);
        if (Math.random() < intensity * 0.5) copy.ratchet = Math.min(8, copy.ratchet + 1);
        return copy;
    }

    function buildBranch(trunk, branch) {
        let seq = [...trunk];
        if (!branch.enabled) return seq;
        switch (branch.transform) {
            case 'reverse':
                seq = [...seq].reverse();
                break;
            case 'inverse':
                seq = seq.map(s => ({ ...s, note: quantizeToScale(60 - (s.note - 60)) }));
                break;
            case 'transpose':
                seq = seq.map(s => ({ ...s, note: quantizeToScale(s.note + branch.transpose) }));
                break;
            case 'mutate':
                seq = seq.map(s => mutateStep(s, 0.5));
                break;
            case 'random':
                seq = seq.map(() => randomStep(trunk[0].note));
                break;
        }
        return seq;
    }

    function buildVoiceSequence(voiceIdx) {
        const length = parseInt(document.querySelector(`.seq-length-input[data-voice="${voiceIdx}"]`).value);
        const root = 48 + voiceIdx * 5;
        const trunk = Array.from({ length }, () => randomStep(root));
        const mutation = parseFloat(document.getElementById('mutation').value) / 100;
        const mutated = trunk.map(step => mutateStep(step, mutation));
        voiceStates[voiceIdx].trunk = mutated;
        voiceStates[voiceIdx].stepIndex = 0;
        voiceStates[voiceIdx].branches = voiceStates[voiceIdx].branches.map((b, i) => ({ ...b, enabled: i < parseInt(document.getElementById('branch').value) }));
        updateSequenceViz(voiceIdx);
    }

    function generateAllSequences() {
        for (let i = 0; i < 4; i++) buildVoiceSequence(i);
    }

    function nextFromLattice(state) {
        const pos = state.lattice.position;
        pos.x = (pos.x + 1) % 8;
        if (pos.x === 0) { pos.y = (pos.y + 1) % 8; }
        const cell = state.lattice.cells[pos.x][pos.y];
        const jitter = (Math.random() - 0.5) * state.lattice.jitterPct;
        return { cell, jitter };
    }

    function pickStep(voiceIdx) {
        const state = voiceStates[voiceIdx];
        const trunk = state.trunk;
        const branches = state.branches.filter(b => b.enabled);
        const pathVal = parseFloat(document.getElementById('path').value) / 100;
        const useBranch = branches[Math.floor(pathVal * branches.length)];
        const seq = useBranch ? buildBranch(trunk, useBranch) : trunk;
        const { cell, jitter } = nextFromLattice(state);
        const stepIdx = seq.length ? state.stepIndex % seq.length : 0;
        state.stepIndex = (stepIdx + 1) % Math.max(1, seq.length);
        const step = { ...seq[stepIdx] };
        if (Math.random() > step.probability * cell.probability) return null;
        step.gate = clamp(step.gate * cell.gate, 0.05, 1.5);
        step.ratchet = clamp(step.ratchet + cell.ratExtra, 1, 8);
        step.altOffset = cell.alt;
        step.note += step.altOffset;
        step.jitter = jitter;
        return step;
    }

    function scheduleVoices(now, lookAhead) {
        const tempoInput = parseInt(document.getElementById('tempo').value);
        const tempo = Number.isFinite(tempoInput) && tempoInput > 0 ? tempoInput : 120;
        baseStepDuration = 60 / tempo / 4;
        for (let i = 0; i < voiceStates.length; i++) {
            const state = voiceStates[i];
            if (voiceMuted[i]) continue;
            if (!state.nextEventTime) state.nextEventTime = now;
            while (state.nextEventTime < now + lookAhead) {
                const division = parseInt(document.querySelector(`.seq-division[data-voice="${i}"]`).value);
                const step = pickStep(i);
                if (step) {
                    const jitterOffset = step.jitter * baseStepDuration;
                    schedulerNote(i, step, state.nextEventTime + jitterOffset);
                }
                state.nextEventTime += baseStepDuration * division;
            }
        }
    }

    function schedulerNote(voiceIdx, step, time) {
        const voice = voiceStates[voiceIdx].synth;
        const gateSeconds = baseStepDuration * step.gate * 2;
        const velocity = step.velocity;
        const ratchets = Math.max(1, Math.round(step.ratchet));
        const microGate = gateSeconds / ratchets;
        for (let r = 0; r < ratchets; r++) {
            const fireTime = time + r * microGate;
            applyEnvelopeStack(voiceIdx, fireTime);
            voice.trigger(step.note, velocity, microGate * 0.9, fireTime);
            triggerEnvelopes(voiceIdx, fireTime);
            reflectPlayhead(voiceIdx, step.note, (time - audioContext.currentTime) * 1000);
        }
    }

    function applyEnvelopeStack(voiceIdx, time) {
        voiceParams[voiceIdx] = { ...voiceBaseParams[voiceIdx] };
        envelopePool.forEach(env => env.trigger(time));
        envelopePool.forEach((env, idx) => {
            const value = env.valueAt(time);
            applyEnvelopeModulation(voiceIdx, idx, value);
        });
    }

    function applyEnvelopeModulation(voiceIdx, envIdx, value) {
        const routing = envelopeAssignments[envIdx];
        if (!routing) return;
        const depth = routing.depth || 0;
        const scaled = value * depth;
        switch (routing.target) {
            case 'harmonicStretch':
                voiceParams[voiceIdx].stretch = clamp(voiceParams[voiceIdx].stretch + scaled * 80, 0, 140);
                break;
            case 'harmonicSlope':
                voiceParams[voiceIdx].slope = clamp(voiceParams[voiceIdx].slope + scaled * 1.1, 0, 2.5);
                break;
            case 'comb':
                voiceParams[voiceIdx].comb = clamp(voiceParams[voiceIdx].comb + scaled * 1.2, 0, 2.5);
                break;
            case 'warp':
                voiceParams[voiceIdx].warp = clamp(voiceParams[voiceIdx].warp + scaled * 90, 0, 160);
                break;
            case 'phase':
                voiceParams[voiceIdx].phase = clamp(voiceParams[voiceIdx].phase + scaled * 90, 0, 160);
                break;
            case 'pan':
                voiceParams[voiceIdx].pan = clamp(voiceParams[voiceIdx].pan + (scaled * 2 - depth), -1, 1);
                break;
            case 'adsr':
                voiceParams[voiceIdx].attack = clamp(voiceParams[voiceIdx].attack + scaled * 400, 1, 2000);
                voiceParams[voiceIdx].decay = clamp(voiceParams[voiceIdx].decay + scaled * 600, 10, 4000);
                voiceParams[voiceIdx].release = clamp(voiceParams[voiceIdx].release + scaled * 1200, 10, 4000);
                break;
            case 'dspA':
                dspGlobals.drive = clamp(dspGlobals.drive + scaled * 0.6, 0, 2);
                break;
            case 'dspB':
                dspGlobals.diffusion = clamp(dspGlobals.diffusion + scaled * 0.6, 0, 1.5);
                break;
            case 'dspC':
                dspGlobals.space = clamp(dspGlobals.space + scaled * 0.8, 0, 1.5);
                break;
            case 'dspD':
                dspGlobals.feedback = clamp(dspGlobals.feedback + scaled * 0.8, 0, 1.5);
                break;
            case 'morph':
                spectralMorphAmount = clamp(spectralMorphAmount + scaled * 0.5, 0, 1);
                applySpectralMorph();
                break;
        }
        if (voiceStates[voiceIdx]?.synth) {
            voiceStates[voiceIdx].synth.setSend(0, 0.12 + scaled * 0.6);
        }
    }

    function triggerEnvelopes(voiceIdx, time) {
        updateDspFromGlobals(time);
    }

    function updateDspFromGlobals(time) {
        if (!audioContext) return;
        const now = time || audioContext.currentTime;
        fxBuses.phaser?.update({ rate: clamp(0.05 + dspGlobals.diffusion * 0.8, 0.05, 2), feedback: clamp(dspGlobals.feedback * 0.2, 0, 0.5) });
        fxBuses.flanger?.update({ depth: clamp(0.002 + dspGlobals.space * 0.01, 0.001, 0.02), feedback: clamp(dspGlobals.feedback * 0.4, 0, 0.7) });
        fxBuses.delay?.update({ time: clamp(0.25 + dspGlobals.space * 6, 0.25, 24), feedback: clamp(0.1 + dspGlobals.feedback * 0.35, 0, 0.7) });
        fxBuses.reverb?.update({ mix: clamp(0.2 + dspGlobals.space * 0.3, 0, 1), size: clamp(0.5 + dspGlobals.diffusion * 0.4, 0.1, 0.95) });
        masterGain?.gain.setTargetAtTime(clamp((parseFloat(document.getElementById('volume').value) / 100) * (1 + dspGlobals.drive * 0.05), 0.0001, 1), now, 0.05);
    }

    function reflectPlayhead(voiceIdx, note, delayMs) {
        const voiceElem = document.getElementById(`voice${voiceIdx + 1}`);
        voiceElem.classList.add('active');
        voiceElem.querySelector('.voice-note').textContent = midiToNoteName(note);
        setTimeout(() => voiceElem.classList.remove('active'), Math.max(120, delayMs + 80));
        const container = document.getElementById(`seq${voiceIdx + 1}`);
        const steps = container.children;
        Array.from(steps).forEach(s => s.classList.remove('playing'));
        if (steps.length) {
            steps[(Math.random() * steps.length) | 0].classList.add('playing');
        }
    }

    function initSequencerViz() {
        for (let v = 0; v < 4; v++) updateSequenceViz(v);
    }

    function updateSequenceViz(voiceIdx) {
        const container = document.getElementById(`seq${voiceIdx + 1}`);
        container.innerHTML = '';
        const state = voiceStates[voiceIdx];
        const trunk = state.trunk;
        trunk.forEach((step, idx) => {
            const div = document.createElement('div');
            div.className = 'seq-step' + (step.active ? '' : ' inactive');
            div.title = `Note ${midiToNoteName(step.note)} | Gate ${(step.gate * 100).toFixed(0)}% | Rat ${step.ratchet}`;
            div.addEventListener('click', () => {
                state.trunk[idx].active = !state.trunk[idx].active;
                updateSequenceViz(voiceIdx);
            });
            container.appendChild(div);
        });
    }

    function initAudio() {
        if (audioContext) return;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        limiter = audioContext.createDynamicsCompressor();
        limiter.threshold.value = -6;
        limiter.knee.value = 0;
        limiter.ratio.value = 12;
        limiter.attack.value = 0.003;
        limiter.release.value = 0.25;

        fxBuses.phaser = new FXPhaser(audioContext);
        fxBuses.flanger = new FXFlanger(audioContext);
        fxBuses.delay = new FXDelay(audioContext);
        fxBuses.reverb = new FXReverb(audioContext);

        masterGain.connect(limiter);
        fxBuses.phaser.output.connect(masterGain);
        fxBuses.flanger.output.connect(masterGain);
        fxBuses.delay.output.connect(masterGain);
        fxBuses.reverb.output.connect(masterGain);
        limiter.connect(audioContext.destination);

        fxBuses.phaser.update({ rate: parseFloat(document.getElementById('phaserRate').value), feedback: parseFloat(document.getElementById('phaserFeedback').value) });
        fxBuses.flanger.update({ depth: parseFloat(document.getElementById('flangerDepth').value), feedback: parseFloat(document.getElementById('flangerFeedback').value) });
        fxBuses.delay.update({ time: parseFloat(document.getElementById('delayTime').value), feedback: parseFloat(document.getElementById('delayFeedback').value) });
        fxBuses.reverb.update({ mix: parseFloat(document.getElementById('reverbMix').value), size: parseFloat(document.getElementById('reverbSize').value) });

        voiceStates.forEach((v, i) => {
            v.synth = new SynthVoice(audioContext, i, fxBuses);
        });

        scheduler = new WebAudioScheduler(audioContext, scheduleVoices);
        updateVolume();
        generateAllSequences();
        populatePatternButtons();
    }

    function populatePatternButtons() {
        const bank = document.getElementById('patternBank');
        bank.innerHTML = '';
        patternBank.forEach((_, idx) => {
            const btn = document.createElement('button');
            btn.className = 'pattern-btn';
            btn.textContent = idx + 1;
            if (idx === selectedPattern) btn.classList.add('active');
            btn.addEventListener('click', () => { selectedPattern = idx; patternManager.load(idx); updatePatternHighlight(); });
            bank.appendChild(btn);
        });
    }

    function updatePatternHighlight() {
        document.querySelectorAll('.pattern-btn').forEach((btn, idx) => {
            btn.classList.toggle('active', idx === selectedPattern);
        });
    }

    function evolveSequences() {
        const evolveRate = parseFloat(document.getElementById('evolveRate').value) / 100;
        if (evolveRate === 0) return;
        voiceStates.forEach((state, idx) => {
            if (Math.random() < evolveRate * 0.03) {
                state.trunk = state.trunk.map(step => mutateStep(step, evolveRate));
                updateSequenceViz(idx);
            }
        });
    }

    function randomizeMacros() {
        Object.keys(macros).forEach(k => macros[k] = Math.random() * 100);
        for (let i = 1; i <= 8; i++) {
            document.getElementById(`macro${i}`).value = macros[[
                'fractalDepth','phaseCoupling','spectralFlux','harmonicDrift','modulationWeb','crossSynthesis','temporalDistort','entropyIndex'
            ][i - 1]];
            document.getElementById(`macro${i}Val`).textContent = Math.round(document.getElementById(`macro${i}`).value);
        }
    }

    function randomizeVoice() {
        const v = voiceParams[currentEditVoice];
        v.spectral = Math.random() * 100;
        v.stretch = Math.random() * 100;
        v.warp = Math.random() * 100;
        v.phase = Math.random() * 100;
        v.attack = Math.random() * 1000;
        v.decay = Math.random() * 2000;
        v.sustain = Math.random() * 100;
        v.release = Math.random() * 3000;
        v.cutoff = Math.random() * 20000;
        v.resonance = Math.random() * 30;
        v.slope = Math.random();
        v.comb = Math.random();
        v.even = Math.random();
        v.pan = Math.random() * 2 - 1;
        voiceBaseParams[currentEditVoice] = { ...v };
        openVoiceEditor(currentEditVoice);
    }

    function randomizeEnvelope(scope) {
        if (scope === 'all') envelopePool.forEach(env => env.randomize());
        else envelopePool[Math.floor(Math.random() * envelopePool.length)].randomize();
        renderEnvelopePool();
    }

    function reseedMatrixAssignments() {
        envelopeAssignments.forEach((slot, idx) => {
            slot.target = envelopeTargets[(idx + Math.floor(Math.random() * envelopeTargets.length)) % envelopeTargets.length].key;
            slot.depth = Math.random() * 0.9;
        });
        renderEnvelopePool();
    }

    function renderEnvelopePool() {
        const container = document.getElementById('envelopePool');
        if (!container) return;
        container.innerHTML = '';
        envelopePool.forEach((env, idx) => {
            const card = document.createElement('div');
            card.className = 'envelope-card';
            card.dataset.idx = idx;
            const header = document.createElement('header');
            header.innerHTML = `<span>ENV ${idx + 1}</span><div class="inline-btns"><button class="small-btn env-toggle" data-env="${idx}">${env.loopEnabled ? 'LOOP' : 'ONE-SHOT'}</button><button class="small-btn env-random" data-env="${idx}">RND</button></div>`;
            const meta = document.createElement('div');
            meta.className = 'envelope-meta';
            meta.innerHTML = `
                <span>Rate: ${env.rate.toFixed(2)} hz</span>
                <span>Segs: ${env.segmentCount}</span>
                <span>Loop A/B: ${env.loopA + 1}/${env.loopB + 1}</span>
                <span>Breakpoints: ${env.breakpoints.length}</span>
            `;
            const routing = document.createElement('div');
            routing.className = 'envelope-routing';
            const select = document.createElement('select');
            select.className = 'env-target';
            select.dataset.env = idx;
            envelopeTargets.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.key;
                opt.textContent = t.label;
                if (envelopeAssignments[idx].target === t.key) opt.selected = true;
                select.appendChild(opt);
            });
            const depth = document.createElement('input');
            depth.type = 'range';
            depth.className = 'env-depth';
            depth.min = 0;
            depth.max = 1;
            depth.step = 0.01;
            depth.value = envelopeAssignments[idx].depth;
            depth.dataset.env = idx;
            routing.appendChild(select);
            routing.appendChild(depth);
            card.appendChild(header);
            card.appendChild(meta);
            card.appendChild(routing);
            container.appendChild(card);
        });
    }

    function reseed(scope) {
        switch (scope) {
            case 'trunk':
                voiceStates.forEach((_, i) => buildVoiceSequence(i));
                break;
            case 'branches':
                voiceStates.forEach(v => v.branches = createDefaultBranches());
                break;
            case 'lattice':
                voiceStates.forEach(v => v.lattice = createDefaultLattice());
                break;
            case 'envelopes':
                randomizeEnvelope('all');
                break;
            default:
                generateAllSequences();
        }
    }

    function silenceEngine() {
        if (!audioContext) return;
        const now = audioContext.currentTime;
        voiceStates.forEach(v => {
            if (v.synth) {
                v.synth.envelopeGain.gain.cancelScheduledValues(now);
                v.synth.envelopeGain.gain.setTargetAtTime(0.0001, now, 0.02);
                v.synth.outputGain.gain.setTargetAtTime(0.0001, now, 0.05);
            }
        });
        Object.values(fxBuses).forEach(bus => {
            if (bus?.feedback) bus.feedback.gain.setTargetAtTime(0, now, 0.05);
            if (bus?.output) bus.output.gain.setTargetAtTime(0.0001, now, 0.05);
        });
        masterGain?.gain.setTargetAtTime(0.0001, now, 0.05);
    }

    function restoreEngineLevels() {
        if (!audioContext) return;
        const now = audioContext.currentTime;
        if (masterGain) masterGain.gain.setTargetAtTime(parseFloat(document.getElementById('volume').value) / 100 * 0.8, now, 0.05);
        Object.values(fxBuses).forEach(bus => {
            if (bus?.output) bus.output.gain.setTargetAtTime(1, now, 0.05);
        });
        fxBuses.phaser?.update({ rate: parseFloat(document.getElementById('phaserRate').value), feedback: parseFloat(document.getElementById('phaserFeedback').value) });
        fxBuses.flanger?.update({ depth: parseFloat(document.getElementById('flangerDepth').value), feedback: parseFloat(document.getElementById('flangerFeedback').value) });
        fxBuses.delay?.update({ time: parseFloat(document.getElementById('delayTime').value), feedback: parseFloat(document.getElementById('delayFeedback').value) });
        fxBuses.reverb?.update({ mix: parseFloat(document.getElementById('reverbMix').value), size: parseFloat(document.getElementById('reverbSize').value) });
    }

    let isPlaying = false;
    let currentEditVoice = 0;

    document.getElementById('startBtn').addEventListener('click', () => {
        if (!audioContext) initAudio();
        if (!isPlaying) {
            isPlaying = true;
            audioContext.resume();
            restoreEngineLevels();
            scheduler.start();
            document.getElementById('startBtn').classList.add('active');
            document.getElementById('stopBtn').classList.remove('active');
            document.getElementById('status').textContent = 'Audio Engine: Active | Sequencer Running (Web Audio scheduler)';
        }
    });

    document.getElementById('stopBtn').addEventListener('click', () => {
        if (isPlaying) {
            isPlaying = false;
            scheduler.stop();
            silenceEngine();
            voiceStates.forEach(v => v.nextEventTime = audioContext.currentTime);
            document.getElementById('startBtn').classList.remove('active');
            document.getElementById('stopBtn').classList.add('active');
            document.getElementById('status').textContent = 'Audio Engine: Active | Sequencer Stopped';
        }
    });

    document.getElementById('globalReseedBtn').addEventListener('click', () => generateAllSequences());

    document.getElementById('evolveBtn').addEventListener('click', (e) => {
        const toggled = e.target.classList.toggle('active');
        e.target.textContent = toggled ? 'EVOLVE: ON' : 'EVOLVE: OFF';
        const loop = () => {
            if (!toggled) return;
            evolveSequences();
            requestAnimationFrame(loop);
        };
        loop();
    });

    document.querySelectorAll('.seq-reseed-btn').forEach(btn => {
        btn.addEventListener('click', () => buildVoiceSequence(parseInt(btn.dataset.voice)));
    });

    document.querySelectorAll('.seq-length-input').forEach(input => {
        input.addEventListener('change', () => {
            const voiceIdx = parseInt(input.dataset.voice);
            buildVoiceSequence(voiceIdx);
            initSequencerViz();
        });
    });

    document.querySelectorAll('.voice-mute-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const voiceIdx = parseInt(btn.dataset.voice);
            voiceMuted[voiceIdx] = !voiceMuted[voiceIdx];
            btn.classList.toggle('muted', voiceMuted[voiceIdx]);
            btn.textContent = voiceMuted[voiceIdx] ? 'UNMUTE' : 'MUTE';
            document.getElementById(`voice${voiceIdx + 1}`).classList.toggle('muted', voiceMuted[voiceIdx]);
        });
    });

    document.getElementById('randomizeMacros').addEventListener('click', randomizeMacros);
    document.getElementById('randomizeVoice').addEventListener('click', randomizeVoice);

    document.querySelectorAll('.voice-edit-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            currentEditVoice = parseInt(btn.dataset.voice);
            openVoiceEditor(currentEditVoice);
        });
    });

    function openVoiceEditor(voiceIdx) {
        const modal = document.getElementById('voiceEditorModal');
        document.getElementById('voiceEditorTitle').textContent = `VOICE ${voiceIdx + 1} EDITOR`;
        const params = voiceParams[voiceIdx];
        Object.keys(params).forEach(key => {
            const slider = document.getElementById(`v_${key}`);
            if (slider) {
                slider.value = params[key];
                document.getElementById(`v_${key}Val`).textContent = key === 'resonance' ? params[key].toFixed(1) : Math.round(params[key]);
            }
        });
        modal.classList.add('active');
    }

    document.getElementById('closeVoiceEditor').addEventListener('click', () => {
        document.getElementById('voiceEditorModal').classList.remove('active');
    });

    document.getElementById('envelopePool').addEventListener('click', (e) => {
        if (e.target.classList.contains('env-random')) {
            const idx = parseInt(e.target.dataset.env);
            envelopePool[idx].randomize();
            renderEnvelopePool();
        }
        if (e.target.classList.contains('env-toggle')) {
            const idx = parseInt(e.target.dataset.env);
            envelopePool[idx].loopEnabled = !envelopePool[idx].loopEnabled;
            renderEnvelopePool();
        }
    });

    document.getElementById('envelopePool').addEventListener('input', (e) => {
        if (e.target.classList.contains('env-target')) {
            const idx = parseInt(e.target.dataset.env);
            envelopeAssignments[idx].target = e.target.value;
        }
        if (e.target.classList.contains('env-depth')) {
            const idx = parseInt(e.target.dataset.env);
            envelopeAssignments[idx].depth = parseFloat(e.target.value);
        }
    });

    document.querySelectorAll('.voice-param').forEach(slider => {
        slider.addEventListener('input', (e) => {
            const param = e.target.dataset.param;
            const value = parseFloat(e.target.value);
            voiceParams[currentEditVoice][param] = value;
            voiceBaseParams[currentEditVoice][param] = value;
            const displayValue = param === 'resonance' ? value.toFixed(1) : Math.round(value);
            document.getElementById(`v_${param}Val`).textContent = displayValue;
        });
    });

    function updateVolume() {
        if (masterGain) {
            masterGain.gain.setValueAtTime(parseFloat(document.getElementById('volume').value) / 100 * 0.8, audioContext.currentTime);
        }
    }

    document.getElementById('tempo').addEventListener('input', (e) => {
        document.getElementById('tempoVal').textContent = e.target.value;
    });

    ['volume', 'evolveRate', 'branch', 'mutation', 'path', 'macro1', 'macro2', 'macro3', 'macro4', 'macro5', 'macro6', 'macro7', 'macro8',
        'phaserRate', 'phaserFeedback', 'flangerDepth', 'flangerFeedback', 'delayTime', 'delayFeedback', 'reverbMix', 'reverbSize']
        .forEach(id => {
            const slider = document.getElementById(id);
            const display = document.getElementById(`${id}Val`);
            if (slider) {
                slider.addEventListener('input', (e) => {
                    if (display) display.textContent = parseFloat(e.target.value);
                    switch (id) {
                        case 'volume': updateVolume(); break;
                        case 'phaserRate': fxBuses.phaser?.update({ rate: parseFloat(e.target.value), feedback: parseFloat(document.getElementById('phaserFeedback').value) }); break;
                        case 'phaserFeedback': fxBuses.phaser?.update({ rate: parseFloat(document.getElementById('phaserRate').value), feedback: parseFloat(e.target.value) }); break;
                        case 'flangerDepth': fxBuses.flanger?.update({ depth: parseFloat(e.target.value), feedback: parseFloat(document.getElementById('flangerFeedback').value) }); break;
                        case 'flangerFeedback': fxBuses.flanger?.update({ depth: parseFloat(document.getElementById('flangerDepth').value), feedback: parseFloat(e.target.value) }); break;
                        case 'delayTime': fxBuses.delay?.update({ time: parseFloat(e.target.value), feedback: parseFloat(document.getElementById('delayFeedback').value) }); break;
                        case 'delayFeedback': fxBuses.delay?.update({ time: parseFloat(document.getElementById('delayTime').value), feedback: parseFloat(e.target.value) }); break;
                        case 'reverbMix': fxBuses.reverb?.update({ mix: parseFloat(e.target.value), size: parseFloat(document.getElementById('reverbSize').value) }); break;
                        case 'reverbSize': fxBuses.reverb?.update({ mix: parseFloat(document.getElementById('reverbMix').value), size: parseFloat(e.target.value) }); break;
                        default:
                            if (id.startsWith('macro')) {
                                const macroMap = {
                                    'macro1': 'fractalDepth', 'macro2': 'phaseCoupling', 'macro3': 'spectralFlux', 'macro4': 'harmonicDrift',
                                    'macro5': 'modulationWeb', 'macro6': 'crossSynthesis', 'macro7': 'temporalDistort', 'macro8': 'entropyIndex'
                                };
                                macros[macroMap[id]] = parseFloat(e.target.value);
                            }
                    }
                });
            }
        });

    document.getElementById('rootNote').addEventListener('change', generateAllSequences);
    document.getElementById('scale').addEventListener('change', generateAllSequences);

    document.getElementById('randomizeOneEnv').addEventListener('click', () => randomizeEnvelope('one'));
    document.getElementById('randomizeAllEnvs').addEventListener('click', () => randomizeEnvelope('all'));
    document.getElementById('reseedMatrix').addEventListener('click', reseedMatrixAssignments);
    document.querySelectorAll('[data-reseed]').forEach(btn => btn.addEventListener('click', () => reseed(btn.dataset.reseed)));
    document.getElementById('modOutputMode').addEventListener('change', (e) => {
        voiceStates.forEach(v => v.macroMode = e.target.value);
    });

    document.getElementById('spectralMorph').addEventListener('input', (e) => {
        spectralMorphAmount = parseFloat(e.target.value);
        applySpectralMorph();
    });
    document.getElementById('captureSnapshotA').addEventListener('click', () => captureSpectralSnapshot('A'));
    document.getElementById('captureSnapshotB').addEventListener('click', () => captureSpectralSnapshot('B'));
    document.getElementById('resetMorph').addEventListener('click', resetMorph);

    document.getElementById('savePattern').addEventListener('click', () => { patternManager.save(selectedPattern); updatePatternHighlight(); });
    document.getElementById('loadPattern').addEventListener('click', () => patternManager.load(selectedPattern));
    document.getElementById('reseedPattern').addEventListener('click', () => patternManager.reseed(selectedPattern));
    document.getElementById('downloadState').addEventListener('click', () => {
        const blob = new Blob([patternManager.export()], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ladders-state.json';
        a.click();
        URL.revokeObjectURL(url);
    });

    renderEnvelopePool();
    applySpectralMorph();
    generateAllSequences();
    initSequencerViz();
</script>
</body>
</html>
